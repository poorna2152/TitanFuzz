
{"jnp.cov": {"seeds": ["import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)"], "initials": ["import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)"], "outputs": {"import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)": {"mutation_layer": 0, "used_as_seed": 30, "parent": null, "filename": "jnp.cov_seed1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef covariance(data):\n    cov = jnp.cov(data)\n    cov = (cov / (N * M))\n    cov = ((cov - cov.mean(0)) / (N * M))\n    cov = (cov / (cov.std(0) + 1e-08))\n    return cov\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.cov_1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef covariance(data):\n    cov = jnp.cov(data)\n    cov = (cov / jnp.linalg.norm(cov))\n    cov = jnp.ascontiguousarray(cov)\n    return cov\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 40, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.cov_3.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    with Path((filename + '.json')).open('w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.cov_30.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    with open(filename.replace('.py', '.metadata.json'), 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.cov_31.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    with open((filename + '_metadata.json'), 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 20, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.cov_32.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    with open((((Path(__file__).parent.parent / 'metadata') / filename) + '_metadata.json'), 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.cov_33.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    with open((('./' + filename) + '/metadata.json'), 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.cov_34.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    with open((filename + '.json'), 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef covariance(data):\n    cov = jnp.cov(data, rowvar=False)\n    return cov\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_covariance = export.export(covariance)(*input_shapes).mlir_module()\nprint(stablehlo_covariance)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=covariance)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.cov_35.py"}}, "p": {"argument": [3, 12], "keyword": [1, 12], "method": [1, 12], "prefix": [1, 22], "prefix-argument": [1, 22], "suffix": [7, 22], "suffix-argument": [1, 2]}, "crashes": [], "g_time": [13.645256757736206, 10.77968430519104, 15.50696611404419, 11.915623903274536, 11.670064926147461, 20.255305528640747, 12.352097988128662, 11.371707677841187, 12.172556161880493], "v_time": [0.005700349807739258, 0.0015213489532470703, 0.2620515823364258, 0.0015022754669189453, 0, 0, 0.26059746742248535, 0, 0.2555239200592041], "tot_time": [13.685386657714844, 10.79837155342102, 15.833935499191284, 11.92647385597229, 11.678791999816895, 20.263269901275635, 12.682518482208252, 11.378059148788452, 12.441380500793457], "tot_prog": [3, 4, 11, 18, 26, 29, 35, 38, 39]}}
{"jnp.dot": {"seeds": ["import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)"], "initials": ["import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)"], "outputs": {"import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)": {"mutation_layer": 0, "used_as_seed": 20, "parent": null, "filename": "jnp.dot_seed1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(beta, y)\n        sum_ = jnp.sum(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.dot_1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(y, beta)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.dot_2.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.dot_3.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(y[:k].at[0].set(alpha), (y[:k].at[k] + (y[:k].at[:(k + 1)].at[0] * (alpha ** 2))))\n        sum_ = jnp.maximum(sum_, (r[k] + y[:k]))\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.dot_4.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.dot_5.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n": {"mutation_layer": 1, "used_as_seed": 20, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.dot_6.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(beta, y)\n        sum_ = jnp.reshape(sum_, ((- 1),))\n        sum_ = (- sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.dot_7.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(alpha, beta)\n        sum_ *= beta\n        sum_ = jnp.sqrt(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.dot_8.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot(y, y) - jnp.dot((alpha * r), (beta * r))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n", "replace_type": "argument", "round": 1, "filename": "jax_seed_output/valid/jnp.dot_9.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, jax.grad(r[k])) / beta)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n", "replace_type": "argument", "round": 1, "filename": "jax_seed_output/valid/jnp.dot_10.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        y = jnp.roll(y, ((- 1) * k), axis=0)\n        y = jnp.dot(y, ((sum_ + jnp.dot(y, y)) / beta))\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n", "replace_type": "argument", "round": 1, "filename": "jax_seed_output/valid/jnp.dot_11.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, (alpha + (beta * r[k]))) / beta)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n", "replace_type": "argument", "round": 1, "filename": "jax_seed_output/valid/jnp.dot_15.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r[(k + 1)]) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = (((- r[k]) - sum_) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 2, "filename": "jax_seed_output/valid/jnp.dot_16.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(beta, y)\n        rk = jax.nn.relu((jnp.dot(alpha, r) / beta))\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 2, "filename": "jax_seed_output/valid/jnp.dot_17.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(r[1::(+ 1)], jnp.cos(beta)) + (jnp.dot(r[k::(- 1)], jnp.sin(beta)) / beta))\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 2, "filename": "jax_seed_output/valid/jnp.dot_18.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(x, beta) + y[k])\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        y[k] = ((y[k] - sum_) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 2, "filename": "jax_seed_output/valid/jnp.dot_19.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, beta) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 2, "filename": "jax_seed_output/valid/jnp.dot_20.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, (jax.random.normal(key, ((k // 2),)) * (r[k] - (beta ** 2)))) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 2, "filename": "jax_seed_output/valid/jnp.dot_21.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(beta, r[:k]) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 2, "filename": "jax_seed_output/valid/jnp.dot_22.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y.at[:k], y[:k]) / beta)\n        y = jnp.roll(y, ((- 1) * k), axis=0)\n        y = jnp.dot(y, ((sum_ + jnp.dot(y, y)) / beta))\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / beta)\n        y = jnp.roll(y, ((- 1) * k), axis=0)\n        y = jnp.dot(y, ((sum_ + jnp.dot(y, y)) / beta))\n", "replace_type": "argument", "round": 3, "filename": "jax_seed_output/valid/jnp.dot_27.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(y[::k], y[::(k + 1)])\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_41.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(y[:k], y[:k])\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_42.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot((alpha * y), beta)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_43.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(jnp.transpose(r[:k]), jnp.dot(jnp.transpose(r[k:]), (r[k:] * r[(k + 1):])))\n        sum_ = jnp.minimum(sum_, jnp.inf)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_44.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(y, (r[k] + (alpha * y[:k])))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_45.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot((alpha * r[k]), y)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_46.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot((alpha * y[k]), y[:k]) / jnp.dot(alpha, y[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_47.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(jnp.conj(y), y) * alpha)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_48.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(y.at[:k], alpha)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[:k].at[:k].at[:k].at[:k], (beta * r[:k].at[:k].at[:k].at[:k]))\n        sum_ = jnp.maximum(sum_, jnp.inf)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "argument", "round": 5, "filename": "jax_seed_output/valid/jnp.dot_49.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = jnp.dot(r[1:(k + 1)][::(- 1)], y[:k])\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_durbin = export.export(durbin)(*input_shapes).mlir_module()\nprint(stablehlo_durbin)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.dot_50.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, beta) / jnp.sum(y))\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n", "replace_type": "argument", "round": 7, "filename": "jax_seed_output/valid/jnp.dot_53.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r[(k - 1)]) / (r[k] - r[(k - 1)]))\n        y[k] = ((sum_ * (1.0 - (beta ** 2))) + ((y * y[k]) / beta))\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n", "replace_type": "argument", "round": 7, "filename": "jax_seed_output/valid/jnp.dot_55.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, y) / k)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n", "replace_type": "argument", "round": 7, "filename": "jax_seed_output/valid/jnp.dot_57.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot(y, beta) + (alpha * y)) / (2 * beta))\n        y = y.at[k].set(sum_)\n        alpha = ((alpha * (1.0 - y)) / beta)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, r) / beta)\n", "replace_type": "argument", "round": 7, "filename": "jax_seed_output/valid/jnp.dot_58.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (((jnp.dot(y, beta) - beta) / (jnp.dot(y, y) - jnp.dot((alpha * r), (beta * r)))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot(y, y) - jnp.dot((alpha * r), (beta * r))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n", "replace_type": "argument", "round": 9, "filename": "jax_seed_output/valid/jnp.dot_66.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot() - jnp.dot((alpha * r), (beta * r))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot(y, y) - jnp.dot((alpha * r), (beta * r))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n", "replace_type": "argument", "round": 9, "filename": "jax_seed_output/valid/jnp.dot_68.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot(y, y) * ((beta * jnp.dot(alpha, beta)) - jnp.dot((alpha * r), (beta * r)))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n": {"mutation_layer": 3, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot(y, y) - jnp.dot((alpha * r), (beta * r))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n", "replace_type": "argument", "round": 9, "filename": "jax_seed_output/valid/jnp.dot_72.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot(y, y) / (jnp.dot(y, y) * ((beta * jnp.dot(alpha, beta)) - jnp.dot((alpha * r), (beta * r))))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n": {"mutation_layer": 4, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = ((jnp.dot(y, y) * ((beta * jnp.dot(alpha, beta)) - jnp.dot((alpha * r), (beta * r)))) / N)\n        y = y.at[0].set((sum_ / beta))\n        alpha = (alpha / ((beta * jnp.dot(y, y)) / beta))\n", "replace_type": "argument", "round": 10, "filename": "jax_seed_output/valid/jnp.dot_77.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(r, alpha) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, (jax.random.normal(key, ((k // 2),)) * (r[k] - (beta ** 2)))) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "suffix-argument", "round": 13, "filename": "jax_seed_output/valid/jnp.dot_91.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(r, y.at[0].at[:k].at) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 256\nkey = jax.random.PRNGKey(0)\nr = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef durbin(r):\n    \"Toeplitz system solver (Durbin's algorithm).\"\n    y = jnp.zeros_like(r)\n    beta = 1.0\n    alpha = (- r[0])\n    y = y.at[0].set(alpha)\n    for k in range(1, N):\n        beta = (beta * (1.0 - (alpha ** 2)))\n        sum_ = (jnp.dot(y, (jax.random.normal(key, ((k // 2),)) * (r[k] - (beta ** 2)))) / beta)\n        sum_ = jnp.clip(sum_, 0.01, 1)\n        sum_ = jax.nn.relu(sum_)\n        alpha = ((- (r[k] + sum_)) / beta)\n        y = y.at[:k].set((y[:k] + (alpha * y[:k][::(- 1)])))\n        y = y.at[k].set(alpha)\n    return y\n", "replace_type": "suffix-argument", "round": 13, "filename": "jax_seed_output/valid/jnp.dot_93.py"}}, "p": {"argument": [38, 82], "keyword": [1, 12], "method": [1, 12], "prefix": [1, 12], "prefix-argument": [1, 12], "suffix": [2, 12], "suffix-argument": [3, 12]}, "crashes": [], "g_time": [9.713441133499146, 5.488971471786499, 6.668118715286255, 5.858358860015869, 7.576153516769409, 11.652357578277588, 7.233301162719727, 5.586717844009399, 5.492265939712524, 11.585612058639526, 6.244009971618652, 11.392624139785767, 19.69576597213745, 19.09032106399536], "v_time": [0.010192155838012695, 0.006356000900268555, 0.009181737899780273, 0.0019516944885253906, 0.0009250640869140625, 0.23297357559204102, 0.002054452896118164, 0.005127668380737305, 0.0026712417602539062, 0.22616028785705566, 0.0020101070404052734, 0.002203702926635742, 0, 0.22402024269104004], "tot_time": [9.794965028762817, 5.527810573577881, 6.742286205291748, 5.905673265457153, 7.58598256111145, 11.961259603500366, 7.257524728775024, 5.624461889266968, 5.525132894515991, 11.862967729568481, 6.277557611465454, 11.41574215888977, 19.70373034477234, 19.335265159606934], "tot_prog": [8, 15, 22, 32, 40, 49, 52, 59, 65, 74, 81, 83, 90, 93]}}
{"jnp.matmul": {"seeds": ["import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jnp.zeros((N,), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef gesummv(A, B, x):\n    'Performs the gesummv kernel.'\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, x)) + (beta * jnp.matmul(B, x)))\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_gesummv = export.export(gesummv)(*input_shapes).mlir_module()\nprint(stablehlo_gesummv)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, x, func=gesummv)", "import logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\nlogging.disable(logging.WARNING)\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\n        return stablehlo_module.operation.get_asm(large_elements_limit=20)\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\n@jax.jit\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((M, K), jnp.float32), jax.ShapeDtypeStruct((K, N), jnp.float32)]\nstablehlo_gemm = export.export(gemm)(*input_shapes).mlir_module()\nprint(get_stablehlo_asm(stablehlo_gemm))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=gemm)", "import jax\nimport jax.numpy as jnp\nimport json\n(NI, NJ, NK, NL) = (512, 512, 512, 512)\nA = (jnp.arange((NI * NK), dtype=jnp.float32).reshape(NI, NK) / (NI * NK))\nB = (jnp.arange((NK * NJ), dtype=jnp.float32).reshape(NK, NJ) / (NK * NJ))\nC = (jnp.arange((NJ * NL), dtype=jnp.float32).reshape(NJ, NL) / (NJ * NL))\n\n@jax.jit\ndef two_mm(A, B, C):\n    'Performs the 2mm kernel.'\n    D = jnp.zeros((NI, NL), dtype=jnp.float32)\n    for _ in range(100):\n        tmp = jnp.matmul(A, B)\n        D = jnp.matmul(tmp, C)\n    return D\ninput_shapes = [jax.ShapeDtypeStruct((NI, NK), jnp.float32), jax.ShapeDtypeStruct((NK, NJ), jnp.float32), jax.ShapeDtypeStruct((NJ, NL), jnp.float32)]\nstablehlo_2mm = export.export(two_mm)(*input_shapes).mlir_module()\nprint(stablehlo_2mm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=two_mm)", "import jax\nimport jax.numpy as jnp\nimport json\n(NI, NJ, NK, NL, NM) = (512, 512, 512, 512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (NI, NK), dtype=jnp.float32)\nB = jax.random.uniform(key, (NK, NJ), dtype=jnp.float32)\nC = jax.random.uniform(key, (NJ, NM), dtype=jnp.float32)\nD = jax.random.uniform(key, (NM, NL), dtype=jnp.float32)\nE = jnp.zeros((NI, NJ), dtype=jnp.float32)\nF = jnp.zeros((NJ, NL), dtype=jnp.float32)\n\n@jax.jit\ndef three_mm(A, B, C, D):\n    'Performs the 3mm kernel.'\n    E = jnp.matmul(A, B)\n    F = jnp.matmul(C, D)\n    G = jnp.matmul(E, F)\n    return G\ninput_shapes = [jax.ShapeDtypeStruct((NI, NK), jnp.float32), jax.ShapeDtypeStruct((NK, NJ), jnp.float32), jax.ShapeDtypeStruct((NJ, NM), jnp.float32), jax.ShapeDtypeStruct((NM, NL), jnp.float32)]\nstablehlo_3mm = export.export(three_mm)(*input_shapes).mlir_module()\nprint(stablehlo_3mm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, D, func=three_mm)", "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nC = jax.random.uniform(key, (N,), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef symm(A, B, C):\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, jnp.matmul(B, C))) + (beta * C))\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_symm = export.export(symm)(*input_shapes).mlir_module()\nprint(stablehlo_symm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=symm)", "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nC = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef syr2k(A, B, C):\n    'Performs the syr2k kernel.'\n    alpha = 1.5\n    beta = 1.2\n    C = ((alpha * (jnp.matmul(A, B.T) + jnp.matmul(B, A.T))) + (beta * C))\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_syr2k = export.export(syr2k)(*input_shapes).mlir_module()\nprint(stablehlo_syr2k)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=syr2k)", "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef atax(A, x):\n    'Performs the atax kernel.'\n    y = jnp.matmul(A, x)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_atax = export.export(atax)(*input_shapes).mlir_module()\nprint(stablehlo_atax)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, x, func=atax)", "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_mvt = export.export(mvt)(*input_shapes).mlir_module()\nprint(stablehlo_mvt)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, y1, y2, func=mvt)", "import jax\nimport jax.numpy as jnp\nimport json\nN = 128\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\n\n@jax.jit\ndef trmm(A, B):\n    'Triangular matrix-multiply.'\n    alpha = 1.5\n    A_tri = jnp.tril(A)\n    B = (alpha * jnp.matmul(A_tri, B))\n    return B\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_trmm = export.export(trmm)(*input_shapes).mlir_module()\nprint(stablehlo_trmm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=trmm)", "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nu1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nu2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nv1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nv2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jax.random.uniform(key, (N,), dtype=jnp.float32)\nz = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((N,), dtype=jnp.float32)\nw = jnp.zeros((N,), dtype=jnp.float32)\n\n@jax.jit\ndef gemver(A, u1, v1):\n    'Gemver kernel with 3 arguments, y calculated inside.'\n    A = (A + jnp.outer(u1, v1))\n    y = jnp.ones(A.shape[0], dtype=A.dtype)\n    x = jnp.matmul(A, y)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_gemver = export.export(gemver)(*input_shapes).mlir_module()\nprint(stablehlo_gemver)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape)}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, u1, v1, func=gemver)", "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\np = jax.random.uniform(key, (N,), dtype=jnp.float32)\nr = jax.random.uniform(key, (M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, p, r):\n    q = jnp.matmul(A, p)\n    s = jnp.matmul(A.T, r)\n    k = (q + s)\n    return k\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, p, r, func=bicg)", "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nC = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef syrk(A, C):\n    'Performs the syrk kernel.'\n    alpha = 1.5\n    beta = 1.2\n    C = ((alpha * jnp.matmul(A, A.T)) + (beta * C))\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_syrk = export.export(syrk)(*input_shapes).mlir_module()\nprint(stablehlo_syrk)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, C, func=syrk)"], "initials": ["import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jnp.zeros((N,), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef gesummv(A, B, x):\n    'Performs the gesummv kernel.'\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, x)) + (beta * jnp.matmul(B, x)))\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_gesummv = export.export(gesummv)(*input_shapes).mlir_module()\nprint(stablehlo_gesummv)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, x, func=gesummv)", "import logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\nlogging.disable(logging.WARNING)\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\n        return stablehlo_module.operation.get_asm(large_elements_limit=20)\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\n@jax.jit\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((M, K), jnp.float32), jax.ShapeDtypeStruct((K, N), jnp.float32)]\nstablehlo_gemm = export.export(gemm)(*input_shapes).mlir_module()\nprint(get_stablehlo_asm(stablehlo_gemm))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=gemm)", "import jax\nimport jax.numpy as jnp\nimport json\n(NI, NJ, NK, NL) = (512, 512, 512, 512)\nA = (jnp.arange((NI * NK), dtype=jnp.float32).reshape(NI, NK) / (NI * NK))\nB = (jnp.arange((NK * NJ), dtype=jnp.float32).reshape(NK, NJ) / (NK * NJ))\nC = (jnp.arange((NJ * NL), dtype=jnp.float32).reshape(NJ, NL) / (NJ * NL))\n\n@jax.jit\ndef two_mm(A, B, C):\n    'Performs the 2mm kernel.'\n    D = jnp.zeros((NI, NL), dtype=jnp.float32)\n    for _ in range(100):\n        tmp = jnp.matmul(A, B)\n        D = jnp.matmul(tmp, C)\n    return D\ninput_shapes = [jax.ShapeDtypeStruct((NI, NK), jnp.float32), jax.ShapeDtypeStruct((NK, NJ), jnp.float32), jax.ShapeDtypeStruct((NJ, NL), jnp.float32)]\nstablehlo_2mm = export.export(two_mm)(*input_shapes).mlir_module()\nprint(stablehlo_2mm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=two_mm)", "import jax\nimport jax.numpy as jnp\nimport json\n(NI, NJ, NK, NL, NM) = (512, 512, 512, 512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (NI, NK), dtype=jnp.float32)\nB = jax.random.uniform(key, (NK, NJ), dtype=jnp.float32)\nC = jax.random.uniform(key, (NJ, NM), dtype=jnp.float32)\nD = jax.random.uniform(key, (NM, NL), dtype=jnp.float32)\nE = jnp.zeros((NI, NJ), dtype=jnp.float32)\nF = jnp.zeros((NJ, NL), dtype=jnp.float32)\n\n@jax.jit\ndef three_mm(A, B, C, D):\n    'Performs the 3mm kernel.'\n    E = jnp.matmul(A, B)\n    F = jnp.matmul(C, D)\n    G = jnp.matmul(E, F)\n    return G\ninput_shapes = [jax.ShapeDtypeStruct((NI, NK), jnp.float32), jax.ShapeDtypeStruct((NK, NJ), jnp.float32), jax.ShapeDtypeStruct((NJ, NM), jnp.float32), jax.ShapeDtypeStruct((NM, NL), jnp.float32)]\nstablehlo_3mm = export.export(three_mm)(*input_shapes).mlir_module()\nprint(stablehlo_3mm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, D, func=three_mm)", "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nC = jax.random.uniform(key, (N,), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef symm(A, B, C):\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, jnp.matmul(B, C))) + (beta * C))\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_symm = export.export(symm)(*input_shapes).mlir_module()\nprint(stablehlo_symm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=symm)", "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nC = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef syr2k(A, B, C):\n    'Performs the syr2k kernel.'\n    alpha = 1.5\n    beta = 1.2\n    C = ((alpha * (jnp.matmul(A, B.T) + jnp.matmul(B, A.T))) + (beta * C))\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_syr2k = export.export(syr2k)(*input_shapes).mlir_module()\nprint(stablehlo_syr2k)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=syr2k)", "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef atax(A, x):\n    'Performs the atax kernel.'\n    y = jnp.matmul(A, x)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_atax = export.export(atax)(*input_shapes).mlir_module()\nprint(stablehlo_atax)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, x, func=atax)", "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_mvt = export.export(mvt)(*input_shapes).mlir_module()\nprint(stablehlo_mvt)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, y1, y2, func=mvt)", "import jax\nimport jax.numpy as jnp\nimport json\nN = 128\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\n\n@jax.jit\ndef trmm(A, B):\n    'Triangular matrix-multiply.'\n    alpha = 1.5\n    A_tri = jnp.tril(A)\n    B = (alpha * jnp.matmul(A_tri, B))\n    return B\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_trmm = export.export(trmm)(*input_shapes).mlir_module()\nprint(stablehlo_trmm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=trmm)", "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nu1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nu2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nv1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nv2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jax.random.uniform(key, (N,), dtype=jnp.float32)\nz = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((N,), dtype=jnp.float32)\nw = jnp.zeros((N,), dtype=jnp.float32)\n\n@jax.jit\ndef gemver(A, u1, v1):\n    'Gemver kernel with 3 arguments, y calculated inside.'\n    A = (A + jnp.outer(u1, v1))\n    y = jnp.ones(A.shape[0], dtype=A.dtype)\n    x = jnp.matmul(A, y)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_gemver = export.export(gemver)(*input_shapes).mlir_module()\nprint(stablehlo_gemver)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape)}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, u1, v1, func=gemver)", "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\np = jax.random.uniform(key, (N,), dtype=jnp.float32)\nr = jax.random.uniform(key, (M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, p, r):\n    q = jnp.matmul(A, p)\n    s = jnp.matmul(A.T, r)\n    k = (q + s)\n    return k\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, p, r, func=bicg)", "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nC = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef syrk(A, C):\n    'Performs the syrk kernel.'\n    alpha = 1.5\n    beta = 1.2\n    C = ((alpha * jnp.matmul(A, A.T)) + (beta * C))\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_syrk = export.export(syrk)(*input_shapes).mlir_module()\nprint(stablehlo_syrk)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, C, func=syrk)"], "outputs": {"import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jnp.zeros((N,), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef gesummv(A, B, x):\n    'Performs the gesummv kernel.'\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, x)) + (beta * jnp.matmul(B, x)))\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_gesummv = export.export(gesummv)(*input_shapes).mlir_module()\nprint(stablehlo_gesummv)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, x, func=gesummv)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.matmul_seed1.py"}, "import logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\nlogging.disable(logging.WARNING)\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\n        return stablehlo_module.operation.get_asm(large_elements_limit=20)\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\n@jax.jit\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((M, K), jnp.float32), jax.ShapeDtypeStruct((K, N), jnp.float32)]\nstablehlo_gemm = export.export(gemm)(*input_shapes).mlir_module()\nprint(get_stablehlo_asm(stablehlo_gemm))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=gemm)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.matmul_seed2.py"}, "import jax\nimport jax.numpy as jnp\nimport json\n(NI, NJ, NK, NL) = (512, 512, 512, 512)\nA = (jnp.arange((NI * NK), dtype=jnp.float32).reshape(NI, NK) / (NI * NK))\nB = (jnp.arange((NK * NJ), dtype=jnp.float32).reshape(NK, NJ) / (NK * NJ))\nC = (jnp.arange((NJ * NL), dtype=jnp.float32).reshape(NJ, NL) / (NJ * NL))\n\n@jax.jit\ndef two_mm(A, B, C):\n    'Performs the 2mm kernel.'\n    D = jnp.zeros((NI, NL), dtype=jnp.float32)\n    for _ in range(100):\n        tmp = jnp.matmul(A, B)\n        D = jnp.matmul(tmp, C)\n    return D\ninput_shapes = [jax.ShapeDtypeStruct((NI, NK), jnp.float32), jax.ShapeDtypeStruct((NK, NJ), jnp.float32), jax.ShapeDtypeStruct((NJ, NL), jnp.float32)]\nstablehlo_2mm = export.export(two_mm)(*input_shapes).mlir_module()\nprint(stablehlo_2mm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=two_mm)": {"mutation_layer": 0, "used_as_seed": 0, "parent": null, "filename": "jnp.matmul_seed3.py"}, "import jax\nimport jax.numpy as jnp\nimport json\n(NI, NJ, NK, NL, NM) = (512, 512, 512, 512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (NI, NK), dtype=jnp.float32)\nB = jax.random.uniform(key, (NK, NJ), dtype=jnp.float32)\nC = jax.random.uniform(key, (NJ, NM), dtype=jnp.float32)\nD = jax.random.uniform(key, (NM, NL), dtype=jnp.float32)\nE = jnp.zeros((NI, NJ), dtype=jnp.float32)\nF = jnp.zeros((NJ, NL), dtype=jnp.float32)\n\n@jax.jit\ndef three_mm(A, B, C, D):\n    'Performs the 3mm kernel.'\n    E = jnp.matmul(A, B)\n    F = jnp.matmul(C, D)\n    G = jnp.matmul(E, F)\n    return G\ninput_shapes = [jax.ShapeDtypeStruct((NI, NK), jnp.float32), jax.ShapeDtypeStruct((NK, NJ), jnp.float32), jax.ShapeDtypeStruct((NJ, NM), jnp.float32), jax.ShapeDtypeStruct((NM, NL), jnp.float32)]\nstablehlo_3mm = export.export(three_mm)(*input_shapes).mlir_module()\nprint(stablehlo_3mm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, D, func=three_mm)": {"mutation_layer": 0, "used_as_seed": 0, "parent": null, "filename": "jnp.matmul_seed4.py"}, "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nC = jax.random.uniform(key, (N,), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef symm(A, B, C):\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, jnp.matmul(B, C))) + (beta * C))\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_symm = export.export(symm)(*input_shapes).mlir_module()\nprint(stablehlo_symm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=symm)": {"mutation_layer": 0, "used_as_seed": 0, "parent": null, "filename": "jnp.matmul_seed5.py"}, "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nC = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef syr2k(A, B, C):\n    'Performs the syr2k kernel.'\n    alpha = 1.5\n    beta = 1.2\n    C = ((alpha * (jnp.matmul(A, B.T) + jnp.matmul(B, A.T))) + (beta * C))\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_syr2k = export.export(syr2k)(*input_shapes).mlir_module()\nprint(stablehlo_syr2k)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, C, func=syr2k)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.matmul_seed6.py"}, "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef atax(A, x):\n    'Performs the atax kernel.'\n    y = jnp.matmul(A, x)\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_atax = export.export(atax)(*input_shapes).mlir_module()\nprint(stablehlo_atax)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, x, func=atax)": {"mutation_layer": 0, "used_as_seed": 0, "parent": null, "filename": "jnp.matmul_seed7.py"}, "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_mvt = export.export(mvt)(*input_shapes).mlir_module()\nprint(stablehlo_mvt)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, y1, y2, func=mvt)": {"mutation_layer": 0, "used_as_seed": 0, "parent": null, "filename": "jnp.matmul_seed8.py"}, "import jax\nimport jax.numpy as jnp\nimport json\nN = 128\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\n\n@jax.jit\ndef trmm(A, B):\n    'Triangular matrix-multiply.'\n    alpha = 1.5\n    A_tri = jnp.tril(A)\n    B = (alpha * jnp.matmul(A_tri, B))\n    return B\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_trmm = export.export(trmm)(*input_shapes).mlir_module()\nprint(stablehlo_trmm)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=trmm)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.matmul_seed9.py"}, "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nu1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nu2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nv1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\nv2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jax.random.uniform(key, (N,), dtype=jnp.float32)\nz = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((N,), dtype=jnp.float32)\nw = jnp.zeros((N,), dtype=jnp.float32)\n\n@jax.jit\ndef gemver(A, u1, v1):\n    'Gemver kernel with 3 arguments, y calculated inside.'\n    A = (A + jnp.outer(u1, v1))\n    y = jnp.ones(A.shape[0], dtype=A.dtype)\n    x = jnp.matmul(A, y)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_gemver = export.export(gemver)(*input_shapes).mlir_module()\nprint(stablehlo_gemver)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape)}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, u1, v1, func=gemver)": {"mutation_layer": 0, "used_as_seed": 0, "parent": null, "filename": "jnp.matmul_seed10.py"}, "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\np = jax.random.uniform(key, (N,), dtype=jnp.float32)\nr = jax.random.uniform(key, (M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, p, r):\n    q = jnp.matmul(A, p)\n    s = jnp.matmul(A.T, r)\n    k = (q + s)\n    return k\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, p, r, func=bicg)": {"mutation_layer": 0, "used_as_seed": 0, "parent": null, "filename": "jnp.matmul_seed11.py"}, "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nC = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef syrk(A, C):\n    'Performs the syrk kernel.'\n    alpha = 1.5\n    beta = 1.2\n    C = ((alpha * jnp.matmul(A, A.T)) + (beta * C))\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32)]\nstablehlo_syrk = export.export(syrk)(*input_shapes).mlir_module()\nprint(stablehlo_syrk)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, C, func=syrk)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.matmul_seed12.py"}, "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C = jax.nn.relu(C)\n    return C\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\nlogging.disable(logging.WARNING)\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\n        return stablehlo_module.operation.get_asm(large_elements_limit=20)\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\n@jax.jit\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((M, K), jnp.float32), jax.ShapeDtypeStruct((K, N), jnp.float32)]\nstablehlo_gemm = export.export(gemm)(*input_shapes).mlir_module()\nprint(get_stablehlo_asm(stablehlo_gemm))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=gemm)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.matmul_1.py"}, "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C_ = jax.pmap(np.linalg.gemm)\n    return C\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\nlogging.disable(logging.WARNING)\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\n        return stablehlo_module.operation.get_asm(large_elements_limit=20)\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\n@jax.jit\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((M, K), jnp.float32), jax.ShapeDtypeStruct((K, N), jnp.float32)]\nstablehlo_gemm = export.export(gemm)(*input_shapes).mlir_module()\nprint(get_stablehlo_asm(stablehlo_gemm))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=gemm)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.matmul_2.py"}, "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 20, "parent": "import logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\nlogging.disable(logging.WARNING)\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\n        return stablehlo_module.operation.get_asm(large_elements_limit=20)\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\n@jax.jit\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((M, K), jnp.float32), jax.ShapeDtypeStruct((K, N), jnp.float32)]\nstablehlo_gemm = export.export(gemm)(*input_shapes).mlir_module()\nprint(get_stablehlo_asm(stablehlo_gemm))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=gemm)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.matmul_3.py"}, "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    return C\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\nlogging.disable(logging.WARNING)\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\n        return stablehlo_module.operation.get_asm(large_elements_limit=20)\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\n@jax.jit\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    return C\ninput_shapes = [jax.ShapeDtypeStruct((M, K), jnp.float32), jax.ShapeDtypeStruct((K, N), jnp.float32)]\nstablehlo_gemm = export.export(gemm)(*input_shapes).mlir_module()\nprint(get_stablehlo_asm(stablehlo_gemm))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, func=gemm)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.matmul_4.py"}, "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\nC = jax.random.uniform(key, (K,), dtype=jnp.float32)\nD = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.matmul_11.py"}, "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, K, dtype=jnp.float32)\nC = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.matmul_12.py"}, "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.normal(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.matmul_15.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef gesummv(A, B, x):\n    'Performs the gesummv kernel.'\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, x)) + (beta * jnp.matmul(B, x)))\n    return y\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jnp.zeros((N,), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef gesummv(A, B, x):\n    'Performs the gesummv kernel.'\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, x)) + (beta * jnp.matmul(B, x)))\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_gesummv = export.export(gesummv)(*input_shapes).mlir_module()\nprint(stablehlo_gesummv)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, x, func=gesummv)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.matmul_35.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef gesummv(A, B, x):\n    'Performs the gesummv kernel.'\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, x)) + (beta * jnp.matmul(B, x)))\n    return y\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n        return jax.tree_map(func, *args)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nB = jax.random.uniform(key, (N, N), dtype=jnp.float32)\nx = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny = jnp.zeros((N,), dtype=jnp.float32)\nalpha = 1.5\nbeta = 1.2\n\n@jax.jit\ndef gesummv(A, B, x):\n    'Performs the gesummv kernel.'\n    alpha = 1.5\n    beta = 1.2\n    y = ((alpha * jnp.matmul(A, x)) + (beta * jnp.matmul(B, x)))\n    return y\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_gesummv = export.export(gesummv)(*input_shapes).mlir_module()\nprint(stablehlo_gesummv)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, B, x, func=gesummv)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.matmul_39.py"}, "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.normal(key, (M, N), dtype=jnp.float32)\nX = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\nC = jax.random.uniform(key, (K,), dtype=jnp.float32)\nD = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport logging\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport json\n\ndef get_stablehlo_asm(module_str: str) -> str:\n    'Returns a pretty-printed StableHLO module with truncated large constants.'\n    with jax_mlir.make_ir_context():\n        stablehlo_module = ir.Module.parse(module_str, context=jax_mlir.make_ir_context())\nkey = jax.random.PRNGKey(0)\n(M, K, N) = (512, 256, 128)\nA = jax.random.uniform(key, (M, K), dtype=jnp.float32)\nB = jax.random.uniform(key, (K, N), dtype=jnp.float32)\nC = jax.random.uniform(key, (K,), dtype=jnp.float32)\nD = jax.random.uniform(key, (K, N), dtype=jnp.float32)\n\ndef gemm(A, B):\n    C = jnp.matmul(A, B)\n    C.flatten = (lambda _: jnp.reshape(C, ((- 1), 1)))\n    C *= (1.0 / jnp.linalg.norm(A, axis=(- 1)))\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "method", "round": 8, "filename": "jax_seed_output/valid/jnp.matmul_44.py"}}, "p": {"argument": [5, 12], "keyword": [1, 12], "method": [5, 22], "prefix": [1, 22], "prefix-argument": [1, 12], "suffix": [3, 12], "suffix-argument": [1, 12]}, "crashes": [], "g_time": [17.41632103919983, 12.987760305404663, 12.988399505615234, 10.909717559814453, 13.884496927261353, 23.942049264907837, 13.26262640953064, 9.837657451629639, 13.281381368637085], "v_time": [0.008280754089355469, 0.001678466796875, 0.7268342971801758, 0.0009465217590332031, 0, 0, 0.3713951110839844, 0.20273160934448242, 0.7167205810546875], "tot_time": [17.490120887756348, 13.008103132247925, 13.83344841003418, 10.923255443572998, 13.893834829330444, 23.950987100601196, 13.708910942077637, 10.056591510772705, 14.098225116729736], "tot_prog": [4, 5, 15, 23, 29, 33, 39, 41, 49]}}
{"jnp.mean": {"seeds": ["import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)"], "initials": ["import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)"], "outputs": {"import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)": {"mutation_layer": 0, "used_as_seed": 40, "parent": null, "filename": "jnp.mean_seed1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    variance = (jnp.mean(data) - mean)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 20, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.mean_1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = (jax.mean(data, axis=0) - jnp.mean(data, axis=0))\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 20, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.mean_2.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jax.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.mean_3.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jax.mean(data, axis=0)\n    variance = jax.variance(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.mean_6.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jax.mean(data, axis=0)\n    variance = jnp.var(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.mean_11.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    variance = (jnp.mean(data) - mean)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        attrs = {'shape': shape, 'dtype': dtype}\n        attrs['name'] = func(x).__name__\n        args_meta.append(attrs)\n    metadata = json.dumps(args_meta, indent=2)\n    return metadata\n\ndef save_metadata(pathname, metadata):\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    variance = (jnp.mean(data) - mean)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.mean_21.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    variance = jnp.mean((data - mean), axis=0)\n    stddev = jnp.sqrt(variance)\n    return ((stddev ** 2) / N)\n\ndef correlation_kernel(data):\n    'Performs the correlation kernel.'\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    variance = (jnp.mean(data) - mean)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "suffix-argument", "round": 7, "filename": "jax_seed_output/valid/jnp.mean_22.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = ((jax.linalg.solve(normalized_data.T, normalized_data) * jnp.linalg.inv(normalized_data.T, normalized_data)) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 8, "filename": "jax_seed_output/valid/jnp.mean_23.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jax.linalg.sqrtm(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 8, "filename": "jax_seed_output/valid/jnp.mean_24.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jax.linalg.inv(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 8, "filename": "jax_seed_output/valid/jnp.mean_25.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 8, "filename": "jax_seed_output/valid/jnp.mean_27.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = ((jax.linalg.eigvals(normalized_data) ** (- 0.5)) * (stddev ** 0.5))\n    return (jax.nn.relu(normalized_data.T, normalized_data) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\n@jax.jit\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = (jnp.matmul(normalized_data.T, normalized_data) / N)\n    return corr\ninput_shapes = [jax.ShapeDtypeStruct((N, M), jnp.float32)]\nstablehlo_correlation = export.export(correlation)(*input_shapes).mlir_module()\nprint(stablehlo_correlation)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(data, func=correlation)", "replace_type": "method", "round": 8, "filename": "jax_seed_output/valid/jnp.mean_29.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.normal(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = ((jax.linalg.solve(normalized_data.T, normalized_data) * jnp.linalg.inv(normalized_data.T, normalized_data)) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(N, M) = (512, 512)\nkey = jax.random.PRNGKey(0)\ndata = jax.random.uniform(key, (N, M), dtype=jnp.float32)\n\ndef correlation(data):\n    'Performs the correlation kernel.'\n    mean = jnp.mean(data, axis=0)\n    stddev = jnp.std(data, axis=0)\n    normalized_data = ((data - mean) / stddev)\n    corr = ((jax.linalg.solve(normalized_data.T, normalized_data) * jnp.linalg.inv(normalized_data.T, normalized_data)) / N)\n    return corr\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "method", "round": 9, "filename": "jax_seed_output/valid/jnp.mean_30.py"}}, "p": {"argument": [2, 12], "keyword": [1, 12], "method": [11, 32], "prefix": [1, 12], "prefix-argument": [1, 12], "suffix": [2, 22], "suffix-argument": [2, 12]}, "crashes": [], "g_time": [14.051107406616211, 13.641427278518677, 13.892521858215332, 9.191240787506104, 21.063496112823486, 11.788234233856201, 11.954115867614746, 12.045463562011719, 9.270587682723999, 8.490541934967041], "v_time": [0.0025603771209716797, 0, 0.267270565032959, 0.0011768341064453125, 0, 0, 0.2490406036376953, 0.001989603042602539, 0.0077266693115234375, 0.1644287109375], "tot_time": [14.071643590927124, 13.647742748260498, 14.275274991989136, 9.202091693878174, 21.07124972343445, 11.793590545654297, 12.217188119888306, 12.061639308929443, 9.36436939239502, 8.736039876937866], "tot_prog": [1, 1, 11, 17, 20, 20, 21, 22, 29, 38]}}
{"jnp.roll": {"seeds": ["import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)", "import jax\nimport jax.numpy as jnp\n(TMAX, N) = (10, 256)\nkey = jax.random.PRNGKey(0)\na = jax.random.uniform(key, (N,), dtype=jnp.float32)\nb = jnp.zeros((N,), dtype=jnp.float32)\n\n@jax.jit\ndef jacobi_1d(a):\n    '1-D Jacobi stencil computation.'\n    for t in range(TMAX):\n        b_new = (((jnp.roll(a, 1) + a) + jnp.roll(a, (- 1))) / 3)\n        a = a.at[1:(- 1)].set(b_new[1:(- 1)])\n    return a\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_jacobi_1d = export.export(jacobi_1d)(*input_shapes).mlir_module()\nprint(stablehlo_jacobi_1d)", "import jax\nimport jax.numpy as jnp\n(TMAX, N) = (10, 128)\nkey = jax.random.PRNGKey(0)\ngrid = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef seidel(grid):\n    '2-D Seidel stencil computation.'\n    for t in range(TMAX):\n        grid_new = ((((jnp.roll(grid, 1, axis=0) + jnp.roll(grid, (- 1), axis=0)) + jnp.roll(grid, 1, axis=1)) + jnp.roll(grid, (- 1), axis=1)) / 4)", "import jax\nimport jax.numpy as jnp\n(TMAX, NX, NY, NZ) = (10, 64, 64, 64)\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (NX, NY, NZ), dtype=jnp.float32)\n\n@jax.jit\ndef head_3d(u):\n    'Heat equation over 3D data domain.'\n    for t in range(TMAX):\n        u_new = ((((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) + jnp.roll(u, 1, axis=2)) + jnp.roll(u, (- 1), axis=2)) / 6)", "import jax\nimport jax.numpy as jnp\n(TMAX, N, M) = (10, 128, 128)\nkey = jax.random.PRNGKey(0)\na = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nb = jnp.zeros((N, M), dtype=jnp.float32)\n\n@jax.jit\ndef jacobi_2d(a):\n    '2-D Jacobi stencil computation.'\n    for t in range(TMAX):\n        b_new = ((((jnp.roll(a, 1, axis=0) + jnp.roll(a, (- 1), axis=0)) + jnp.roll(a, 1, axis=1)) + jnp.roll(a, (- 1), axis=1)) / 4)"], "initials": ["import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)", "import jax\nimport jax.numpy as jnp\n(TMAX, N) = (10, 256)\nkey = jax.random.PRNGKey(0)\na = jax.random.uniform(key, (N,), dtype=jnp.float32)\nb = jnp.zeros((N,), dtype=jnp.float32)\n\n@jax.jit\ndef jacobi_1d(a):\n    '1-D Jacobi stencil computation.'\n    for t in range(TMAX):\n        b_new = (((jnp.roll(a, 1) + a) + jnp.roll(a, (- 1))) / 3)\n        a = a.at[1:(- 1)].set(b_new[1:(- 1)])\n    return a\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_jacobi_1d = export.export(jacobi_1d)(*input_shapes).mlir_module()\nprint(stablehlo_jacobi_1d)", "import jax\nimport jax.numpy as jnp\n(TMAX, N) = (10, 128)\nkey = jax.random.PRNGKey(0)\ngrid = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef seidel(grid):\n    '2-D Seidel stencil computation.'\n    for t in range(TMAX):\n        grid_new = ((((jnp.roll(grid, 1, axis=0) + jnp.roll(grid, (- 1), axis=0)) + jnp.roll(grid, 1, axis=1)) + jnp.roll(grid, (- 1), axis=1)) / 4)", "import jax\nimport jax.numpy as jnp\n(TMAX, NX, NY, NZ) = (10, 64, 64, 64)\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (NX, NY, NZ), dtype=jnp.float32)\n\n@jax.jit\ndef head_3d(u):\n    'Heat equation over 3D data domain.'\n    for t in range(TMAX):\n        u_new = ((((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) + jnp.roll(u, 1, axis=2)) + jnp.roll(u, (- 1), axis=2)) / 6)", "import jax\nimport jax.numpy as jnp\n(TMAX, N, M) = (10, 128, 128)\nkey = jax.random.PRNGKey(0)\na = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nb = jnp.zeros((N, M), dtype=jnp.float32)\n\n@jax.jit\ndef jacobi_2d(a):\n    '2-D Jacobi stencil computation.'\n    for t in range(TMAX):\n        b_new = ((((jnp.roll(a, 1, axis=0) + jnp.roll(a, (- 1), axis=0)) + jnp.roll(a, 1, axis=1)) + jnp.roll(a, (- 1), axis=1)) / 4)"], "outputs": {"import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)": {"mutation_layer": 0, "used_as_seed": 30, "parent": null, "filename": "jnp.roll_seed1.py"}, "import jax\nimport jax.numpy as jnp\n(TMAX, N) = (10, 256)\nkey = jax.random.PRNGKey(0)\na = jax.random.uniform(key, (N,), dtype=jnp.float32)\nb = jnp.zeros((N,), dtype=jnp.float32)\n\n@jax.jit\ndef jacobi_1d(a):\n    '1-D Jacobi stencil computation.'\n    for t in range(TMAX):\n        b_new = (((jnp.roll(a, 1) + a) + jnp.roll(a, (- 1))) / 3)\n        a = a.at[1:(- 1)].set(b_new[1:(- 1)])\n    return a\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_jacobi_1d = export.export(jacobi_1d)(*input_shapes).mlir_module()\nprint(stablehlo_jacobi_1d)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.roll_seed2.py"}, "import jax\nimport jax.numpy as jnp\n(TMAX, N) = (10, 128)\nkey = jax.random.PRNGKey(0)\ngrid = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef seidel(grid):\n    '2-D Seidel stencil computation.'\n    for t in range(TMAX):\n        grid_new = ((((jnp.roll(grid, 1, axis=0) + jnp.roll(grid, (- 1), axis=0)) + jnp.roll(grid, 1, axis=1)) + jnp.roll(grid, (- 1), axis=1)) / 4)": {"mutation_layer": 0, "used_as_seed": 0, "parent": null, "filename": "jnp.roll_seed3.py"}, "import jax\nimport jax.numpy as jnp\n(TMAX, NX, NY, NZ) = (10, 64, 64, 64)\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (NX, NY, NZ), dtype=jnp.float32)\n\n@jax.jit\ndef head_3d(u):\n    'Heat equation over 3D data domain.'\n    for t in range(TMAX):\n        u_new = ((((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) + jnp.roll(u, 1, axis=2)) + jnp.roll(u, (- 1), axis=2)) / 6)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.roll_seed4.py"}, "import jax\nimport jax.numpy as jnp\n(TMAX, N, M) = (10, 128, 128)\nkey = jax.random.PRNGKey(0)\na = jax.random.uniform(key, (N, M), dtype=jnp.float32)\nb = jnp.zeros((N, M), dtype=jnp.float32)\n\n@jax.jit\ndef jacobi_2d(a):\n    '2-D Jacobi stencil computation.'\n    for t in range(TMAX):\n        b_new = ((((jnp.roll(a, 1, axis=0) + jnp.roll(a, (- 1), axis=0)) + jnp.roll(a, 1, axis=1)) + jnp.roll(a, (- 1), axis=1)) / 4)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.roll_seed5.py"}, "\nimport jax\nimport jax.numpy as jnp\n(TMAX, N) = (10, 256)\nkey = jax.random.PRNGKey(0)\na = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef jacobi_1d(a):\n    '1-D Jacobi stencil computation.'\n    for t in range(TMAX):\n        b_new = (((jnp.roll(jnp.roll(a, (- 1)), (- 1)) + a) + jnp.roll(a, (- 1))) / 3)\n        a = a.at[1:(- 1)].set(b_new[1:(- 1)])\n    return a\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\n(TMAX, N) = (10, 256)\nkey = jax.random.PRNGKey(0)\na = jax.random.uniform(key, (N,), dtype=jnp.float32)\nb = jnp.zeros((N,), dtype=jnp.float32)\n\n@jax.jit\ndef jacobi_1d(a):\n    '1-D Jacobi stencil computation.'\n    for t in range(TMAX):\n        b_new = (((jnp.roll(a, 1) + a) + jnp.roll(a, (- 1))) / 3)\n        a = a.at[1:(- 1)].set(b_new[1:(- 1)])\n    return a\ninput_shapes = [jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_jacobi_1d = export.export(jacobi_1d)(*input_shapes).mlir_module()\nprint(stablehlo_jacobi_1d)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.roll_1.py"}, "\nimport jax\nimport jax.numpy as jnp\n(TMAX, NX, NY, NZ) = (10, 64, 64, 64)\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (NX, NY, NZ), dtype=jnp.float32)\n\ndef head_3d(u):\n    'Heat equation over 3D data domain.'\n    for t in range(TMAX):\n        u_new = ((((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jax.roll(u, (- 1), axis=1)) + jnp.roll(u, 1, axis=2)) + jnp.roll(u, (- 1), axis=2)) / 6)\n": {"mutation_layer": 1, "used_as_seed": 30, "parent": "import jax\nimport jax.numpy as jnp\n(TMAX, NX, NY, NZ) = (10, 64, 64, 64)\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (NX, NY, NZ), dtype=jnp.float32)\n\n@jax.jit\ndef head_3d(u):\n    'Heat equation over 3D data domain.'\n    for t in range(TMAX):\n        u_new = ((((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) + jnp.roll(u, 1, axis=2)) + jnp.roll(u, (- 1), axis=2)) / 6)", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.roll_13.py"}, "\nimport jax\nimport jax.numpy as jnp\nN = 512\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n        (yield u_new.sum(axis=0))\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)", "replace_type": "suffix", "round": 5, "filename": "jax_seed_output/valid/jnp.roll_32.py"}, "\nimport jax\nimport jax.numpy as jnp\nN = 512\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)", "replace_type": "suffix", "round": 5, "filename": "jax_seed_output/valid/jnp.roll_33.py"}, "\nimport jax\nimport jax.numpy as jnp\nN = 512\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n        u += u_new\n    return (np.roll(u, (- 1), axis=0) - u)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)", "replace_type": "suffix", "round": 5, "filename": "jax_seed_output/valid/jnp.roll_34.py"}, "\nimport jax\nimport jax.numpy as jnp\nN = 512\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n    return u_new\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)", "replace_type": "suffix", "round": 5, "filename": "jax_seed_output/valid/jnp.roll_35.py"}, "\nimport jax\nimport jax.numpy as jnp\nN = 512\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll() + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)", "replace_type": "suffix-argument", "round": 6, "filename": "jax_seed_output/valid/jnp.roll_36.py"}, "\nimport jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, (- 3), axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n        u = u_new\n    return u\n\n@jax.jit\ndef dij(u):\n    'Performs the dij kernel.'\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, 1, axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)", "replace_type": "suffix-argument", "round": 6, "filename": "jax_seed_output/valid/jnp.roll_37.py"}, "\nimport jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, (- 3), axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n        u = u_new\n    return u\n\ndef dij(u):\n    'Performs the dij kernel.'\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, (- 3), axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n        u = u_new\n    return u\n\n@jax.jit\ndef dij(u):\n    'Performs the dij kernel.'\n", "replace_type": "suffix", "round": 10, "filename": "jax_seed_output/valid/jnp.roll_45.py"}, "\nimport jax\nimport jax.numpy as jnp\nN = 512\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, (- 3), axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n        u = u_new\n    return u\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nN = 512\nT = 10\nkey = jax.random.PRNGKey(0)\nu = jax.random.uniform(key, (N, N), dtype=jnp.float32)\n\n@jax.jit\ndef adi(u):\n    'Performs the adi kernel.'\n    for t in range(T):\n        u_new = ((((jnp.roll(u, (- 3), axis=0) + jnp.roll(u, (- 1), axis=0)) + jnp.roll(u, 1, axis=1)) + jnp.roll(u, (- 1), axis=1)) / 4)\n        u = u_new\n    return u\n\n@jax.jit\ndef dij(u):\n    'Performs the dij kernel.'\n", "replace_type": "suffix", "round": 10, "filename": "jax_seed_output/valid/jnp.roll_46.py"}}, "p": {"argument": [2, 12], "keyword": [1, 12], "method": [2, 12], "prefix": [1, 12], "prefix-argument": [1, 22], "suffix": [7, 32], "suffix-argument": [3, 22]}, "crashes": [], "g_time": [6.926068544387817, 9.712541103363037, 11.123608827590942, 5.947164058685303, 16.75061869621277, 11.024178266525269, 11.285152912139893, 7.9070799350738525, 11.628007888793945, 18.25313138961792, 19.033828258514404], "v_time": [0.0032906532287597656, 0.0023021697998046875, 0.2991516590118408, 0.0012900829315185547, 0, 0.25779151916503906, 0.0051457881927490234, 0, 0, 0, 0.2539501190185547], "tot_time": [6.9522364139556885, 9.731209516525269, 11.454819679260254, 5.962342023849487, 16.756908893585205, 11.306109428405762, 11.30744743347168, 7.912297964096069, 11.638202667236328, 18.25906205177307, 19.31379222869873], "tot_prog": [6, 9, 18, 26, 31, 35, 39, 41, 43, 44, 49]}}
{"jnp.transpose": {"seeds": ["import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_mvt = export.export(mvt)(*input_shapes).mlir_module()\nprint(stablehlo_mvt)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, y1, y2, func=mvt)"], "initials": ["import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_mvt = export.export(mvt)(*input_shapes).mlir_module()\nprint(stablehlo_mvt)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, y1, y2, func=mvt)"], "outputs": {"import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_mvt = export.export(mvt)(*input_shapes).mlir_module()\nprint(stablehlo_mvt)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, y1, y2, func=mvt)": {"mutation_layer": 0, "used_as_seed": 10, "parent": null, "filename": "jnp.transpose_seed1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A.T), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_mvt = export.export(mvt)(*input_shapes).mlir_module()\nprint(stablehlo_mvt)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, y1, y2, func=mvt)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.transpose_1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 1, "used_as_seed": 50, "parent": "import jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\n@jax.jit\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\ninput_shapes = [jax.ShapeDtypeStruct((N, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32)]\nstablehlo_mvt = export.export(mvt)(*input_shapes).mlir_module()\nprint(stablehlo_mvt)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(A, y1, y2, func=mvt)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jnp.transpose_2.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jax.random.uniform((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jnp.transpose_13.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A.T), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    if (func is None):\n        func = mvt\n    metadata = json.dumps({'function': func}, indent=4)\n    with open((path + '.meta'), 'w') as f:\n        json.dump(metadata, f, indent=2)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A.T), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.transpose_26.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A.T), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    if (not func):\n        args_meta[0]['func'] = (lambda : mvt(*args_meta))\n    return args_meta\n\ndef main(args):\n    (args, meta, func_args, func_kwargs) = args\n    if args.meta_file:\n        metadata = {}\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\nN = 512\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (N, N), dtype=jnp.float32)\ny1 = jax.random.uniform(key, (N,), dtype=jnp.float32)\ny2 = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef mvt(A, y1, y2):\n    'Performs the mvt kernel.'\n    x1 = jnp.zeros((N,), dtype=jnp.float32)\n    x2 = jnp.zeros((N,), dtype=jnp.float32)\n    x1 = (x1 + jnp.matmul(jnp.transpose(A.T), y1))\n    x2 = (x2 + jnp.matmul(A, y2))\n    x = (x1 + x2)\n    return x\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jnp.transpose_27.py"}}, "p": {"argument": [3, 12], "keyword": [1, 12], "method": [2, 12], "prefix": [1, 12], "prefix-argument": [1, 12], "suffix": [3, 22], "suffix-argument": [1, 12]}, "crashes": [], "g_time": [16.780109643936157, 14.992089748382568, 13.209652662277222, 9.261157035827637, 22.489574670791626, 11.65972089767456, 18.053653240203857, 13.288191318511963], "v_time": [0.004719972610473633, 0.0030982494354248047, 0.3710975646972656, 0.0009386539459228516, 0, 0, 0.3679323196411133, 0.004260540008544922], "tot_time": [16.874423265457153, 15.032669067382812, 13.637709379196167, 9.271036863327026, 22.49807906150818, 11.664703845977783, 18.44911241531372, 13.324438571929932], "tot_prog": [6, 9, 15, 20, 25, 25, 27, 29]}}
{"jax.scipy.signal.convolve2d": {"seeds": ["import jax\nimport jax.numpy as jnp\nimport json\n(W, H) = (256, 256)\nkey = jax.random.PRNGKey(0)\nimg = jax.random.uniform(key, (H, W), dtype=jnp.float32)\n\n@jax.jit\ndef deriche(img):\n    'Simple edge detection filter (deriche).'\n    Kx = jnp.array([[1, 0, (- 1)], [2, 0, (- 2)], [1, 0, (- 1)]], dtype=jnp.float32)\n    Ky = jnp.array([[1, 2, 1], [0, 0, 0], [(- 1), (- 2), (- 1)]], dtype=jnp.float32)\n    gx = jax.scipy.signal.convolve2d(img, Kx, mode='same')\n    gy = jax.scipy.signal.convolve2d(img, Ky, mode='same')\n    edge = jnp.sqrt(((gx ** 2) + (gy ** 2)))\n    return edge\ninput_shapes = [jax.ShapeDtypeStruct((H, W), jnp.float32)]\nstablehlo_deriche = export.export(deriche)(*input_shapes).mlir_module()\nprint(stablehlo_deriche)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(img, func=deriche)"], "initials": ["import jax\nimport jax.numpy as jnp\nimport json\n(W, H) = (256, 256)\nkey = jax.random.PRNGKey(0)\nimg = jax.random.uniform(key, (H, W), dtype=jnp.float32)\n\n@jax.jit\ndef deriche(img):\n    'Simple edge detection filter (deriche).'\n    Kx = jnp.array([[1, 0, (- 1)], [2, 0, (- 2)], [1, 0, (- 1)]], dtype=jnp.float32)\n    Ky = jnp.array([[1, 2, 1], [0, 0, 0], [(- 1), (- 2), (- 1)]], dtype=jnp.float32)\n    gx = jax.scipy.signal.convolve2d(img, Kx, mode='same')\n    gy = jax.scipy.signal.convolve2d(img, Ky, mode='same')\n    edge = jnp.sqrt(((gx ** 2) + (gy ** 2)))\n    return edge\ninput_shapes = [jax.ShapeDtypeStruct((H, W), jnp.float32)]\nstablehlo_deriche = export.export(deriche)(*input_shapes).mlir_module()\nprint(stablehlo_deriche)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(img, func=deriche)"], "outputs": {"import jax\nimport jax.numpy as jnp\nimport json\n(W, H) = (256, 256)\nkey = jax.random.PRNGKey(0)\nimg = jax.random.uniform(key, (H, W), dtype=jnp.float32)\n\n@jax.jit\ndef deriche(img):\n    'Simple edge detection filter (deriche).'\n    Kx = jnp.array([[1, 0, (- 1)], [2, 0, (- 2)], [1, 0, (- 1)]], dtype=jnp.float32)\n    Ky = jnp.array([[1, 2, 1], [0, 0, 0], [(- 1), (- 2), (- 1)]], dtype=jnp.float32)\n    gx = jax.scipy.signal.convolve2d(img, Kx, mode='same')\n    gy = jax.scipy.signal.convolve2d(img, Ky, mode='same')\n    edge = jnp.sqrt(((gx ** 2) + (gy ** 2)))\n    return edge\ninput_shapes = [jax.ShapeDtypeStruct((H, W), jnp.float32)]\nstablehlo_deriche = export.export(deriche)(*input_shapes).mlir_module()\nprint(stablehlo_deriche)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(img, func=deriche)": {"mutation_layer": 0, "used_as_seed": 40, "parent": null, "filename": "jax.scipy.signal.convolve2d_seed1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(W, H) = (256, 256)\nkey = jax.random.PRNGKey(0)\nimg = jax.random.uniform(key, (H, W), dtype=jnp.float32)\n\ndef deriche(img):\n    'Simple edge detection filter (deriche).'\n    Kx = jnp.array([[1, 0, (- 1)], [2, 0, (- 2)], [1, 0, (- 1)]], dtype=jnp.float32)\n    Ky = jnp.array([[1, 2, 1], [0, 0, 0], [(- 1), (- 2), (- 1)]], dtype=jnp.float32)\n    gx = jax.scipy.signal.convolve2d(img, Kx, mode='same')\n": {"mutation_layer": 1, "used_as_seed": 40, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(W, H) = (256, 256)\nkey = jax.random.PRNGKey(0)\nimg = jax.random.uniform(key, (H, W), dtype=jnp.float32)\n\n@jax.jit\ndef deriche(img):\n    'Simple edge detection filter (deriche).'\n    Kx = jnp.array([[1, 0, (- 1)], [2, 0, (- 2)], [1, 0, (- 1)]], dtype=jnp.float32)\n    Ky = jnp.array([[1, 2, 1], [0, 0, 0], [(- 1), (- 2), (- 1)]], dtype=jnp.float32)\n    gx = jax.scipy.signal.convolve2d(img, Kx, mode='same')\n    gy = jax.scipy.signal.convolve2d(img, Ky, mode='same')\n    edge = jnp.sqrt(((gx ** 2) + (gy ** 2)))\n    return edge\ninput_shapes = [jax.ShapeDtypeStruct((H, W), jnp.float32)]\nstablehlo_deriche = export.export(deriche)(*input_shapes).mlir_module()\nprint(stablehlo_deriche)\n\ndef generate_metadata(*args, func=None):\n    args_meta = []\n    for x in args:\n        shape = list(x.shape)\n        dtype = ('matrix' if (len(shape) > 1) else 'vector')\n        args_meta.append({'type': dtype, 'shape': shape})\n    metadata = {'args': args_meta}\n    if (func is not None):\n        output_shape_dtype = jax.eval_shape(func, *args)\n        metadata['output'] = {'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector'), 'shape': list(output_shape_dtype.shape), 'type': ('matrix' if (len(output_shape_dtype.shape) > 1) else 'vector')}\n    filename = Path(__file__).name.replace('.py', '')\n    pathname = (((filename + '/') + filename) + '.json')\n    with open(pathname, 'w') as f:\n        json.dump(metadata, f, indent=2)\n    return metadata\ngenerate_metadata(img, func=deriche)", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jax.scipy.signal.convolve2d_1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(W, H) = (256, 256)\nkey = jax.random.PRNGKey(0)\nimg = jax.random.uniform(key, (H, W), dtype=jnp.float32)\n\ndef deriche(img):\n    'Simple edge detection filter (deriche).'\n    Kx = jnp.array([[1, 0, (- 1)], [2, 0, (- 2)], [1, 0, (- 1)]], dtype=jnp.float32)\n    Ky = jnp.array([[1, 2, 1], [0, 0, 0], [(- 1), (- 2), (- 1)]], dtype=jnp.float32)\n    gx = jax.scipy.signal.convolve2d(img, Kx, mode='same')\n    gy = jax.scipy.signal.convolve2d(img, Ky, mode='same')\n": {"mutation_layer": 2, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(W, H) = (256, 256)\nkey = jax.random.PRNGKey(0)\nimg = jax.random.uniform(key, (H, W), dtype=jnp.float32)\n\ndef deriche(img):\n    'Simple edge detection filter (deriche).'\n    Kx = jnp.array([[1, 0, (- 1)], [2, 0, (- 2)], [1, 0, (- 1)]], dtype=jnp.float32)\n    Ky = jnp.array([[1, 2, 1], [0, 0, 0], [(- 1), (- 2), (- 1)]], dtype=jnp.float32)\n    gx = jax.scipy.signal.convolve2d(img, Kx, mode='same')\n", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jax.scipy.signal.convolve2d_5.py"}}, "p": {"argument": [1, 12], "keyword": [1, 12], "method": [2, 12], "prefix": [1, 12], "prefix-argument": [1, 22], "suffix": [2, 22], "suffix-argument": [1, 12]}, "crashes": [], "g_time": [16.68201994895935, 19.593761682510376, 14.323137283325195, 9.411191463470459, 18.0009663105011, 15.38747525215149, 13.195067405700684, 5.704933166503906, 11.012620210647583], "v_time": [0, 0, 0.25750303268432617, 0.0009613037109375, 0, 0, 0.25293493270874023, 0, 0], "tot_time": [16.688843727111816, 19.600467920303345, 14.598946571350098, 9.419753551483154, 18.005167722702026, 15.39124870300293, 13.45702600479126, 5.715083599090576, 11.015786409378052], "tot_prog": [0, 0, 1, 2, 3, 4, 5, 6, 6]}}
{"jax.scipy.sparse.linalg.bicgstab": {"seeds": ["import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)"], "initials": ["import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)"], "outputs": {"import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)": {"mutation_layer": 0, "used_as_seed": 20, "parent": null, "filename": "jax.scipy.sparse.linalg.bicgstab_seed1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    return s\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_1.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A.astype(jnp.float32), b.astype(jnp.float32), x.astype(jnp.float32))\n    s += (jnp.eye((M - (M * N)), dtype=jnp.float32) - jnp.eye(M, dtype=jnp.float32))\n": {"mutation_layer": 1, "used_as_seed": 20, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_2.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b, check_finite=jax.config.update('check_finite', True))\n    s = jnp.clip(s, 0, 1.0)\n    return s\n": {"mutation_layer": 1, "used_as_seed": 30, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)", "replace_type": "argument", "round": 0, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_3.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A.astype(jnp.float32), b.astype(jnp.float32), x.astype(jnp.float32))\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A.astype(jnp.float32), b.astype(jnp.float32), x.astype(jnp.float32))\n    s += (jnp.eye((M - (M * N)), dtype=jnp.float32) - jnp.eye(M, dtype=jnp.float32))\n", "replace_type": "method", "round": 2, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_7.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\n": {"mutation_layer": 1, "used_as_seed": 10, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_27.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n": {"mutation_layer": 1, "used_as_seed": 0, "parent": "import jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\n@jax.jit\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\ninput_shapes = [jax.ShapeDtypeStruct((M, N), jnp.float32), jax.ShapeDtypeStruct((N,), jnp.float32), jax.ShapeDtypeStruct((M,), jnp.float32)]\nstablehlo_bicg = export.export(bicg)(*input_shapes).mlir_module()\nprint(stablehlo_bicg)", "replace_type": "suffix", "round": 6, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_28.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = (jax.scipy.sparse.linalg.bicgstab(A, x) + b)\n    s = jnp.clip(s, 1e-09, np.inf)\n    return s\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\n", "replace_type": "suffix-argument", "round": 7, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_29.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 2, "used_as_seed": 20, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\n", "replace_type": "suffix-argument", "round": 7, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_30.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, B)\n": {"mutation_layer": 2, "used_as_seed": 30, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\n", "replace_type": "suffix-argument", "round": 7, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_31.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    s = jnp.sqrt(jnp.sum(s))\n    s = jax.scipy.sparse.linalg.spsolve(A, b)\n": {"mutation_layer": 2, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x0=x)\n    return s\n", "replace_type": "suffix-argument", "round": 7, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_32.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    a = jnp.dot(s, np.conj(a))\n    s = jnp.linalg.solve(a, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n    return jnp.dot(s, jnp.linalg.solve(A.T, x))\n\ndef kullback_leibler(A, B):\n    (sA, sB) = jnp.linalg.svd(A)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "suffix-argument", "round": 8, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_33.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    s = jnp.dot(s, jnp.conj(s))\n    s = jnp.linalg.solve(A, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n    s = jnp.dot(s, jnp.conj(x))\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "suffix-argument", "round": 8, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_34.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab((jnp.dot(A, x) / jnp.sqrt(jnp.dot(x, jnp.conj(A)))), b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "suffix-argument", "round": 8, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_35.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, jnp.linalg.solve(A, b))\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "suffix-argument", "round": 8, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_36.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b.flatten(), x)\n    return s\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, B)\n", "replace_type": "suffix-argument", "round": 9, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_37.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(jnp.dot(s, jnp.conj(A)), x, b)\n    s = jax.scipy.sparse.linalg.bicg(jnp.dot(s, jnp.conj(A)), s)\n    s = jax.scipy.sparse.linalg.bicgstab(jnp.dot(s, jnp.conj(A)), s)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "argument", "round": 10, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_38.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b, tol=1e-06)\n    s = jnp.real((s + tol))\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "argument", "round": 10, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_39.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "argument", "round": 10, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_40.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, b, x)\n    A = jnp.dot(s, jnp.conj(A))\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "argument", "round": 10, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_41.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b, True)\n    s = jnp.dot(s, j)\n    s = jnp.linalg.solve(A, s)\n    s = jax.scipy.sparse.linalg.spdiags(s, 0, m, n, format=jnp.sp)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 3, "used_as_seed": 10, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "argument", "round": 10, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_42.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(jnp.dot(A.T, x), A, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "argument", "round": 10, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_43.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A.dot(x), b, check_finite=False)\n    return jnp.real(s)\n\ndef lin_comb_lsq(A, b, x):\n    (m, n) = A.shape\n    A = jax.scipy.sparse.spdiags(A, 0, m, n, format=jnp.sp)\n    s = jnp.dot(s, j)\n    s = jnp.linalg.solve(A, s)\n    s = jax.scipy.sparse.linalg.spdiags(s, 0, m, n, format=jnp.sp)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 4, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b, True)\n    s = jnp.dot(s, j)\n    s = jnp.linalg.solve(A, s)\n    s = jax.scipy.sparse.linalg.spdiags(s, 0, m, n, format=jnp.sp)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "argument", "round": 11, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_45.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A.T, A.T)\n    s = jax.scipy.sparse.linalg.spdiags(s, 0, m, n, format=jnp.sp)\n    s = jnp.dot(s, j)\n    s = jnp.linalg.solve(A, s)\n    s = jax.scipy.sparse.linalg.spdiags(s, 0, m, n, format=jnp.sp)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n": {"mutation_layer": 4, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\nb = jax.random.uniform(key, (N,), dtype=jnp.float32)\nx = jnp.zeros((M,), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b, True)\n    s = jnp.dot(s, j)\n    s = jnp.linalg.solve(A, s)\n    s = jax.scipy.sparse.linalg.spdiags(s, 0, m, n, format=jnp.sp)\n    b = jnp.dot(s, jnp.conj(b))\n    s = jnp.linalg.solve(A, b)\n", "replace_type": "argument", "round": 11, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_46.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, B)\n", "replace_type": "argument", "round": 12, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_47.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, x, b)\n    return jnp.asarray(s)\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, B)\n", "replace_type": "argument", "round": 12, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_49.py"}, "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, a, b)\n    return s.toarray()\n": {"mutation_layer": 3, "used_as_seed": 0, "parent": "\nimport jax\nimport jax.numpy as jnp\nimport json\n(M, N) = (512, 512)\nkey = jax.random.PRNGKey(0)\nA = jax.random.uniform(key, (M, N), dtype=jnp.float32)\n\ndef bicg(A, b, x):\n    s = jax.scipy.sparse.linalg.bicgstab(A, B)\n", "replace_type": "argument", "round": 13, "filename": "jax_seed_output/valid/jax.scipy.sparse.linalg.bicgstab_51.py"}}, "p": {"argument": [15, 52], "keyword": [1, 12], "method": [2, 12], "prefix": [1, 12], "prefix-argument": [1, 12], "suffix": [3, 22], "suffix-argument": [10, 32]}, "crashes": [], "g_time": [6.265034198760986, 9.264019966125488, 14.136805534362793, 5.551884889602661, 16.613951444625854, 11.369168043136597, 10.83115005493164, 8.800502300262451, 9.185365438461304, 7.367305517196655, 5.250364303588867, 5.585197925567627, 4.883255481719971, 20.56594204902649], "v_time": [0.005252838134765625, 0.002383708953857422, 0.4129610061645508, 0.0009245872497558594, 0, 0, 0.40882110595703125, 0.0057220458984375, 0.006709575653076172, 0.0032432079315185547, 0.3724377155303955, 0.003571033477783203, 0.0038650035858154297, 0.0018613338470458984], "tot_time": [6.2941436767578125, 9.28535795211792, 14.57013988494873, 5.559939384460449, 16.619017601013184, 11.384876251220703, 11.251779556274414, 8.829155206680298, 9.220907211303711, 7.375836133956909, 5.669159412384033, 5.60750150680542, 4.89708137512207, 20.574036359786987], "tot_prog": [3, 6, 10, 19, 23, 26, 28, 32, 36, 37, 44, 46, 49, 51]}}